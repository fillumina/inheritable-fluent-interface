Inheritance with classes using fluent interface
===============================================

[Fluent interface](https://en.wikipedia.org/wiki/Fluent_interface) is a
technique that uses chaining methods to create a more fluent and
natural data representation that implements a domain specific language
(DLS). In its simplest form it consists in the usage of named
parameters instead of the classical anonymous method call.

Confront this standard java code for a method call

```java
    double pmi = calculatePmi(193, 94, 150);
```

with the same using fluent interface

```java
    double pmi = new AdvancedBMICalculator()
                .height(193)
                .weight(94)
                .waistCircumference(150)
                .calculatePmi();
```

The named parameters are much easier to read and remember and less prone
to confusion than an anonymous sequence of numbers.
Of course there are performance implications involved: fluent interfaces cannot
be used with immutable classes and they are obviously slower.
In fact they are mostly used on public APIs that must be clear and easy to use,
in complex builders and DSLs.

### Use a fluent interface

To use a fluent interface is pretty straight-forward, they can even be
auto-generated by most IDEs (see
[my own netbeans plug-in]
(http://plugins.netbeans.org/plugin/55184/constants-fluent-setters-and-builder-generator)).

This is an example of a BMI calculator implemented using fluent interface:

```java
    public class WrongBMICalculator {
        protected int height;
        protected int weight;

        public WrongBMICalculator height(final int value) {
            this.height = value;
            return this;
        }

        public WrongBMICalculator weight(final int value) {
            this.weight = value;
            return this;
        }

        public double calculatePmi() {
            double heightInMeters = height / 100.0;
            return weight / (heightInMeters * heightInMeters);
        }
    }
```

Instead of returning the usual ```void``` the setters return
the object itself so that they can be chained together. This way the normal
java way of building a
[Java Beans]
(http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html)
by setters

```java
    Person person = new Person();
    person.setAge(34);
    person.setHeight(177);
    person.setWeight(65);
```

can be rewritten in the following much shorter version:

```java
    Person person = new Person().age(34).height(177).weight(65);
```

When used to create DSLs or builders (which are not usually Java Beans) the
usual convention can be abandoned for using the parameter name directly
(so _age()_ instead of _setAge()_).

### Extending a fluent interface

There is a problem when one tries to _extend_ a class using fluent interface
because the type returned by the fluent setters refers to the parent class,
not the extended, so the methods of the extending class will not be
available after calling a parent's method.

Example of extended class:

```java
    public class WrongAdvancedBMICalculator extends WrongBMICalculator {
        private int waistCircumference;

        @Override
        public double calculatePmi() {
            return waistCircumference /
                    (Math.pow(super.calculatePmi(), 2.0/3.0) * Math.pow(height / 100, 1/3.2));
        }

        public WrongAdvancedBMICalculator waistCircumference(final int value) {
            this.waistCircumference = value;
            return this;
        }
    }
```

When using the extended class after a parent method is called the extended ones
will not be accessible anymore because the type returned by _weight(..)_ is
referring to the parent not the extended class.

```java
    new WrongAdvancedBMICalculator().height(193).weight(94)
            .waistCircumference(150) // <-- causes an ERROR
            .calculatePmi();
```

To overcome this problem a parameter (_T_) must be added to the parent class:

```java
    public class CorrectBMICalculator<T extends CorrectBMICalculator<T>> {
        protected int height;
        protected int weight;

        @SuppressWarnings("unchecked")
        public T height(final int value) {
            this.height = value;
            return (T) this;
        }

        @SuppressWarnings("unchecked")
        public T weight(final int value) {
            this.weight = value;
            return (T) this; // cannot be avoided
        }

        public double calculatePmi() {
            double heightInMeters = height / 100.0;
            return weight / (heightInMeters * heightInMeters);
        }
    }
```

When this class is extended the parameter will take care of managing the
correct static reference:

```java
    public class CorrectAdvancedBMICalculator
            extends CorrectBMICalculator<CorrectAdvancedBMICalculator> {
        private int waistCircumference;

        @Override
        public double calculatePmi() {
            return waistCircumference /
                    (Math.pow(super.calculatePmi(), 2.0/3.0) *
                    Math.pow(height / 100, 1/3.2));
        }

        public CorrectAdvancedBMICalculator waistCircumference(final int value) {
            this.waistCircumference = value;
            return this;
        }
    }
```

So when called it will work as expected:

```java
    double pmi = new CorrectAdvancedBMICalculator()
                    .height(193)
                    .weight(94)
                    .waistCircumference(150) // called after parent's method
                    .calculatePmi();

```