Inheritance with classes using fluent interface
===============================================

[Fluent interface](https://en.wikipedia.org/wiki/Fluent_interface) is a
technique that allows to set parameters in a more natural way and avoids
the confusion of having to set many different parameters in a method or
constructor all possibly having equal types.

Confront the following standard java code:

```java
    double pmi = calculatePmi(193, 94, 150);
```

with the following that uses fluent interface:

```java
    double pmi = new AdvancedBMICalculator()
                .height(193)
                .weight(94)
                .waistCircumference(150)
                .calculatePmi();
```

the former results anonymous, difficult to remember and confusing.
Of course there are performance implications involved, fluent interface is
mostly used on public API that must be clear and easy to use, mainly on builders.

To write a fluent interface is pretty straight-forward, they can even be
auto-generated by most IDE (see
[my own netbeans plug-in]
(http://plugins.netbeans.org/plugin/55184/constants-fluent-setters-and-builder-generator)).

This is an example:

```java
    public class WrongBMICalculator {
        protected int height;
        protected int weight;

        public WrongBMICalculator height(final int value) {
            this.height = value;
            return this;
        }

        public WrongBMICalculator weight(final int value) {
            this.weight = value;
            return this;
        }

        public double calculatePmi() {
            double heightInMeters = height / 100.0;
            return weight / (heightInMeters * heightInMeters);
        }
    }
```

But there is a problem when one tries to _extend_ a class using fluent interface
because the type returned by the fluent setters refers to the parent class,
not the extended, so the methods of the extending class will not be
available after calling a parent's method.

Example of extended class:

```java
    public class WrongAdvancedBMICalculator extends WrongBMICalculator {
        private int waistCircumference;

        @Override
        public double calculatePmi() {
            return waistCircumference /
                    (Math.pow(super.calculatePmi(), 2.0/3.0) * Math.pow(height / 100, 1/3.2));
        }

        public WrongAdvancedBMICalculator waistCircumference(final int value) {
            this.waistCircumference = value;
            return this;
        }
    }
```

When using the extended class after a parent method is called the extended ones
will not be accessible anymore because the type returned by _weight(..)_ is
referring to the parent not the extended class.

```java
    new WrongAdvancedBMICalculator().height(193).weight(94)
            .waistCircumference(150) // <-- causes an ERROR
            .calculatePmi();
```

To overcome this problem a parameter should be added to the parent class:

```java
    public class CorrectBMICalculator<T extends CorrectBMICalculator<T>> {
        protected int height;
        protected int weight;

        @SuppressWarnings("unchecked")
        public T height(final int value) {
            this.height = value;
            return (T) this;
        }

        @SuppressWarnings("unchecked")
        public T weight(final int value) {
            this.weight = value;
            return (T) this; // cannot be avoided
        }

        public double calculatePmi() {
            double heightInMeters = height / 100.0;
            return weight / (heightInMeters * heightInMeters);
        }
    }
```

When this class is extended the parameter will take care of managing the
correct static reference:

```java
    public class CorrectAdvancedBMICalculator
            extends CorrectBMICalculator<CorrectAdvancedBMICalculator> {
        private int waistCircumference;

        @Override
        public double calculatePmi() {
            return waistCircumference /
                    (Math.pow(super.calculatePmi(), 2.0/3.0) *
                    Math.pow(height / 100, 1/3.2));
        }

        public CorrectAdvancedBMICalculator waistCircumference(final int value) {
            this.waistCircumference = value;
            return this;
        }
    }
```

So when called it will work as expected:

```java
    double pmi = new CorrectAdvancedBMICalculator()
                    .height(193)
                    .weight(94)
                    .waistCircumference(150) // called after parent's method
                    .calculatePmi();

```